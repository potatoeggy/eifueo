# ECE 124: Digital Circuits

## Base / radix conversion

Please see [ECE 150: C++#Non-decimal numbers](/1a/ece150/#non-decimal numbers) for more information.

## Binary logic

A **binary logic variable** is a variable that has exactly two states:

- 0, or false (switch open)
- 1, or true (switch closed)

**Binary logic functions** are any function that satisfies the following type signature:

```python
BoolFunc = Callable[[bool | BoolFunc, ...], bool]
```

In other words:

 - it must accept a number of booleans and/or other logic functions, and
 - it must return exactly one boolean.

These can be expressed via truth table inputs/outputs, algebraically, or via a logical circuit schematic.

### Logical operators

Operator precedence is () > NOT > AND > OR.

The **AND** operator returns true if and only if **all** arguments are true.

$$A\cdot B \text{ or }AB$$

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/AND_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)

The **OR** operator returns true if and only if **at least one** argument is true.

$$A+B$$

<img src="https://upload.wikimedia.org/wikipedia/commons/1/16/OR_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **NOT** operator returns the opposite of its singular input.

$$\overline A \text{ or } A'$$

<img src="https://upload.wikimedia.org/wikipedia/commons/6/60/NOT_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **NAND** operator is equivalent to **NOT AND**.

$$\overline{A\cdot B}$$

<img src="https://upload.wikimedia.org/wikipedia/commons/e/e6/NAND_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **NOR** operator is equivalent to **NOT OR**.

$$\overline{A+B}$$

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c6/NOR_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **XOR** operator returns true if and only if the inputs are not equal to each other.

$$A\oplus B$$

<img src="https://upload.wikimedia.org/wikipedia/commons/1/17/XOR_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **XNOR** operator is equivalent to **NOT XOR**.

$$\overline{A\oplus B}$$

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b8/XNOR_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

### Buffer gates

The **buffer** gate returns the input without any changes, and is usually used for adding delays into circuits.

<img src="https://upload.wikimedia.org/wikipedia/commons/7/75/Digital_buffer.svg" width=200>(Source: Wikimedia Commons</img>

A **tri-state buffer** gate controls whether the input affects the circuit at all. When the controlling input is off, the input is disconnected from the rest of the system, leaving the output of the buffer as a third state **Z** (high impedance).

One example of a tri-state buffer is a switch.

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c0/Tristate_buffer.svg" width=400>(Source: Wikimedia Commons)</img>

!!! example
    Tri-state buffers are often used to implement **select inputs** or **multiplexers** — setting the mux switch in one direction or another only allows signals from one input to pass through.
    <img src="https://upload.wikimedia.org/wikipedia/commons/1/16/Multiplexer2.svg" width=400>(Source: Wikimedia Commons)</img>

### NAND/NOR completeness

NAND and NOR are **universal gates** — some combination of them can form any other logic gate. Constructions of other gates using only these gates are called **NAND-NAND realisations** or **NOR-NOR realisations**.

This is useful in SOP as if two ANDs feed into an OR, all can be turned into NANDs to achieve the same result.

!!! example
    NOT can be expressed purely with NAND as $A$ NAND $A$:
    
    <img src="https://upload.wikimedia.org/wikipedia/commons/3/3f/NOT_from_NAND.svg" width=150>(Source: Wikimedia Commons)</img>

### Postulates

In binary algebra, if $x,y,z\in\mathbb B$ such that $\mathbb B=\{0, 1\}$:

The **identity element** for **AND** $1$ is such that any $x\cdot 1 = x$.

The **identity element** for **OR** $0$ is such that any $x + 0 = x$.

In this space, it can be deduced that $x+x'=1$ and $x\cdot x'=0$.

**De Morgan's laws** are much easier to express in boolean algebra, and denote distributing a negation by flipping the operator:

$$
(x\cdot y)'=x'+y' \\
(x+y)=x'\cdot y'
$$

Please see [ECE 108: Discrete Math 1#Operator laws](/1b/ece108/#operator-laws) for more information.

AND and OR are commutative.

- $x\cdot y=y\cdot x$
- $x+y=y+x$

AND and OR are associative.

- $x\cdot(y\cdot z)=(x\cdot y)\cdot z)$
- ...

AND and OR are distributive with each other.

- $x\cdot (y+z)=x\cdot y+z\cdot z$

A term that depends on another term ORed together can be "absorbed".

- $x+x\cdot y=x$
- $x\cdot(x+y)=x$

If a term being true also results in other ORed terms being true, it is redundant and can be eliminated via consensus.

- $x\cdot y+y\cdot z+x'\cdot z=x\cdot y+x'\cdot z$
  - if y and z are true, at least one of the other two terms must be true
- $(x+y)\cdot (y+z)\cdot(x'+z)=(x+y)\cdot (x'+z)$

The **synthesis** of an algebraic formula represents its implementation via logic gates. In this course, its total cost is the sum of all inputs to all gates and the number of gates, *excluding* initial inputs of "true" or an initial negation.

In order to deduce an algebraic expression from a truth table, **OR** all of the rows in which the function returns true and simplify.

??? example
    Prove that $(x+y)\cdot(x+y')=x$:
    
    \begin{align*}
    \tag{distributive property}(x+y)\cdot(x+y')&=xx+xy'+yx+yy' \\
    \tag{$yy'$ = 0, $xx=x$}&=x + xy' + yx \\
    \tag{distributive, commutative properties}&= x(1+y'+y) \\
    \tag{1 + ... = 1}&= x(1) \\
    &=x
    \end{align*}
    
    Prove that $xy+yz+x'z=xy+x'z$:
    
    \begin{align*}
    \tag{$x+x'=1$}xy+yz+x'z&=xy+yz(x+x')+x'z \\
    \tag{distributive property}&=xy+xyz+x'yz+x'z \\
    \tag{distributive property}&=x(y+yz) + x'(yz+z) \\
    \tag{distributive property}&=xy(1+z) + x'z(y+1) \\
    \tag{$1+k=1$}&=xy(1) + x'z(1) \\
    \tag{$1\cdot k=k$}&= xy+x'z
    \end{align*}

### Minterms and maxterms

The **minterm** $m$ is a **product** term where all variables in the function appear once. There are $2^n$ minterms for each function, where $n$ is the number of input variables.

To determine the relevant function, the subscript can be converted to binary and each function variable set such that:

- if the digit is $1$, the complement is used, and
- if the digit is $0$, the original is used.

$$m_j=x_1+x_2+\dots x_n$$

!!! example
    For a function that accepts three variables:
    
    - there are eight minterms, from $m_0$ to $m_7$.
    - the sixth minterm $m_6=xyz'$ because $6=0b110$.
    
    For a sample function defined by the following minterms:
    
    $$
    \begin{align*}
    f(x_1,x_2,x_3)&=\sum m(1,2,5) \\
    &=m_1+m_2+m_5 \\
    &=x_1x_2x_3' + x_1x_2'x_3 + x_1'x_2x_3'
    \end{align*}
    $$

The **maxterm** $M$ is a **sum** term where all variables in the function appear once. It is more or less the same as a minterm, except the condition for each variable is **reversed** (i.e., $0$ indicates the complement).

$$M_j=x_1+x_2+\dots +x_n$$

!!! example
    For a sample function defined by the following maxterms:
    
    \begin{align*}
    f(x_1,x_2,x_3,x_4)&=\prod M(1,2,8,12) \\
    &=M_1M_2M_8M_{12} \\
    \end{align*}

??? example
    Prove that $\sum m(1,2,3,4,5,6,7)=x_1+x_2+x_3$: **(some shortcuts taken for visual clarity)**
    
    \begin{align*}
    \sum m(1,2,3,4,5,6,7) &=001+011+111+010+110+100+000 \\
    \tag{SIMD distribution}&=001+010+100 \\
    &=x_1+x_2+x_3
    \end{align*}

A **canonical sum of products (SOP)** is a function expressed as a sum of minterms.

$$f(x_1,x_2,\dots)=\sum m(a,b, \dots)$$

A **canonical product of sums (POS)** is a function expressed as a product of maxterms.

$$f(x_1,x_2,\dots)=\prod M(a,b,\dots)$$

## Transistors

Binary is represented in hardware via switches called **transistors**. Above a certain voltage threshold, its output is $1$, whlie it is $0$ if below a threshold instead.

A transistor has three inputs/outputs:

- A ground
- An input **source**, which has voltage that determines whether the circuit is connected to the ground
- An output **drain**, which will either be grounded or have a voltage depending on whether the switch is closed.

<img src="https://upload.wikimedia.org/wikipedia/commons/6/61/IGFET_N-Ch_Enh_Labelled_simplified.svg" width=200>(Source: Wikimedia Commons)</img>

A **negative logic** transistor uses a NOT bubble to represent that it is closed while the voltage is **below** a threshold.

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c4/IGFET_P-Ch_Enh_Labelled_simplified.svg" width=200>(Source: Wikimedia Commons)</img>

## Hardware

!!! definition
    - A **programmable logic gate** does shit
    - A **programmable logic array** does more shit
    - **Programmable array logic** is the shit being done

### FPGAs

A **field-programmable gate array** (FPGA) is hardware that does not come with factory-fabricated AND and OR gates, requiring the user to set them up themselves. It contains:

- input/output pads
- routing channels (to connect with physical wires and switches)
- logic blocks (that are user-programmed to behave like gates)
    - lookup tables (LUTs) inside the logic gates, which are a small amount of memory

## Gray code

The Gray code is a binary number system that has any two adjacent numbers differing by **exactly one bit**. It is used to optimise the number of gates in a function.

The 1-bit Gray code is $0, 1$. To convert an $n$-bit Gray code to an $n+1$-bit Gray code:

- Mirror the code: $0,1,1,0$
- Add $0$ to the original and $1$ to the new ones: $00, 01, 11, 10$

Sorting truth table inputs in the order of the Gray code makes optimisation easier to do.

A **"don't care"** is represented by a $d$ in truth tables. It is used for optimisation if the state of that output doesn't matter, and can be treated as a one or a zero as desired.

It can be more efficient to optimise two different functions differently such that they are more optimised when combined.

### K-maps

Karnaugh maps are an alternate representation of truth tables arranged by the Gray code.

- Coordinates are the input values to the function
- The output square of the coordinates is the output value of the function
- Headers are sorted by Gray code (multiple variables can be combined by increasing the number of bits in the Gray code)

Each 1 square is effectively a minterm, and finding the least number of rectangles that only cover "1"s allows for the simplest algebraic form of the truth table to be deduced. If needed, rectangles can wrap around on any side. The same rules apply to optimise for maxterms (product of sums), or $f'$, by optimising for zeros.

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b7/K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg" width=500>(Source: Wikimedia Commons)</img>

A K-map for five variables can be expressed in two maps for four variables — one with the fifth variable set to zero, and the other set to 1.

### Multiplexers

An $n$-input mux has $\lceil\log_2 n\rceil$ **select inputs** all in the same mux.

!!! example
    A 4-1 multiplexer. $f=s_0's_1A+s_0's_1B+s_0s_1'C+s_0s_1D$
    
    <img src="https://upload.wikimedia.org/wikipedia/commons/7/75/Multiplexer_4-to-1.svg" width=300>(Source: Wikimedia Commons)</img>

**Shannon's expansion theorem** states that any function can be turned into a function that purely uses multiplexers:

$$
\begin{align*}
f(w_1,\dots, w_n) &=w_1f_{w_1} + w_1'f_{w_1'} \\
&= w_1f(1, \dots, w_n) = w_1'f(0, \dots, w_n)
\end{align*}
$$

A **demultiplexer** has one input, $n$ select inputs, and up to $2^n$ outputs that carry the input signal depending on the select input.

<img src="https://upload.wikimedia.org/wikipedia/commons/4/48/Demultiplexer.png" width=400>(Source: Wikimedia Commons)</img>

A **binary encoder** takes $2^n$ inputs and $n$ outputs, with the binary representation of the $n$ outputs indicating the inputs enabled by binary index.

## Sequential circuits

!!! definition
    - A **combinatorial circuit** is dependent on present signals.
    - A **sequential circuit** is dependent on past and present signals, using storage elements to track state.

**Synchronous** sequential circuits only change signals at discrete times, such as with clock signals. Asynchronous circuits change whenever.

### Clocks

!!! definition
    - The **period** $t$ is the duration of one clock cycle.
    - The **frequency** $f$ is the reciprocal of the period.
    - The **rising edge** is the instant a clock changes from $0$ to $1$.
    - The **falling edge** is the instant a clock changes from $1$ to $0$.

### Storage elements

A **basic latch** changes based on its input signal level such that it is level-sensitive.

A **gated latch** is a basic latch as well as a control input that locks the current state. The latch is only togglable when the control input is on.

A **flip-flop** contains two gated latches and a control input. The state is only adjustable during the edges of the control signal, so it can only change up to once per cycle.

### Asynchronous latches

An **RS-NOR** basic latch has a *set* input that must be *reset* before being set again, with one output representing each state. Setting both to one resets both outputs to zero.

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c6/R-S_mk2.gif" width=300>(Source: Wikimedia Commons)</img>

| $R$ | $S$ | $Q$ | $Q'$ |
| --- | --- | --- | --- |
| 0 | 0 | no change | no change |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 0 | 0 |

An **RS-NAND** basic latch operates the same way, and looks practically the same, except shifting to $(1, 1)$ resets both to zero instead, and $(0, 0)$ causes no change.

### Synchronous latches

A **NAND gated latch** only allows changes when the clock control input *clk* is on.

<img src="https://upload.wikimedia.org/wikipedia/commons/e/e1/SR_%28Clocked%29_Flip-flop_Diagram.svg" width=400>(Source: Wikimedia Commons)</img>

A **gated D latch** effectively stores $R$ and $S$ by assuming that they are the complement for each other, setting $R$ as $D$ and $S$ as $D'$ or vice versa. This **level-sensitive** latch is commonly used to store past state as there is no change when *clk* is zero.

<img src="https://upload.wikimedia.org/wikipedia/commons/c/cb/D-type_Transparent_Latch_%28NOR%29.svg" width=400>(Source: Wikimedia Commons)</img>

### Flip-flops

**Edge-triggered flip-flops** only change state on the edge of a clock. A negative-edge D flip flop below changes only at the **falling edge** of the clock and is greated with two gated D latches in series. A positive-edge D flip flop can be created by inverting both enable inputs.

<img src="https://upload.wikimedia.org/wikipedia/commons/5/52/Negative-edge_triggered_master_slave_D_flip-flop.svg" width=500>(Source: Wikimedia Commons)</img>

The asynchronous operations **clear** and **preset** can be added to force the state of the flip-flop to 0 or 1, respectively. To make them synchronous, the input $D$ can be replaced with $D\text{ and clear}'$. These operations are **active low**.

<img src="https://upload.wikimedia.org/wikipedia/commons/8/8c/D-Type_Flip-flop.svg" width=200>(Source: Wikimedia Commons</img>

A **T flip-flop** holds state if $T=0$ or **toggles** state if $T=1$.

<img src="https://upload.wikimedia.org/wikipedia/commons/a/a9/T-Type_Flip-flop.svg" width=200>(Source: Wikimedia Commons</img>

!!! example
    <img src="https://upload.wikimedia.org/wikipedia/commons/3/3b/Dual-edge-triggered-flip-flop-XOR.png" width=500>(Source: Wikimedia Commons)</img>

A **JK flip-flop** acts as a **D flip-flop** if $J\neq K$ and as a **T flip-flop** if $J=K$.

<img src="https://upload.wikimedia.org/wikipedia/commons/3/37/JK_Flip-flop_%28Simple%29_Symbol.svg" width=200>(Source: Wikimedia Commons)</img>

### Timing analysis

Because flip-flop outputs only change on an active clock edge, there are **propagation delays** before the state changes completely.

- The **setup time** $t_{su}$ is the waiting time the input must be held stable **before** the active clock edge
- The **hold time** $t_h$ is the time the input must be held stable **after** the active clock edge
- The **clock-to-output time** $t_{cq}$ is the time required for the output to stabilise after the active clock edge

A **timing violation** occurs if these timing parameters are not met, which limits clock cycle frequency.

### Registers

!!! definition
    - An **n-bit register** stores *n* bits.

A flip-flop is a one-bit register.

A **shift register** is a chain of redstone repeaters, consisting of a chain of flip-flops with each output connected to the next input.

<img src="https://upload.wikimedia.org/wikipedia/commons/4/45/4-Bit_SIPO_Shift_Register.svg" width=300>(Source: Wikimedia Commons)</img>

An **up-counter** increments its binary value on input. A **down-counter** decrements its value. It is **synchronous** if all bits update simultaneously.

## VHDL

VHDL is a hardware schematic language.

<img src="https://static.javatpoint.com/tutorial/digital-electronics/images/multiplexer3.png" width=600 />

For example, the basic 2-to-1 multiplexer expressed above can be programmed as:

```vhdl
entity two_one_mux is
    port (a0, s, a1 : in    bit;
          f         : out   bit);
end two_one_mux

architecture LogicFunc of two_one_mux is
    begin
        y <= (a0 AND s) OR (NOT s AND a1);
    end LogicFunc;
```

In this case, the inputs are `a0, s, a1` that lead to an output `y`. All input/output is of type `bit` (a boolean).

The **architecture** defines how inputs translate to outputs via functions. These all run **concurrently**.

