# ECE 124: Digital Circuits

## Base / radix conversion

Please see [ECE 150: C++#Non-decimal numbers](/1a/ece150/#non-decimal numbers) for more information.

## Binary logic

A **binary logic variable** is a variable that has exactly two states:

- 0, or false (switch open)
- 1, or true (switch closed)

**Binary logic functions** are any function that satisfies the following type signature:

```python
BoolFunc = Callable[[bool | BoolFunc, ...], bool]
```

In other words:

 - it must accept a number of booleans and/or other logic functions, and
 - it must return exactly one boolean.

These can be expressed via truth table inputs/outputs, algebraically, or via a logical circuit schematic.

### Logical operators

Operator precedence is () > NOT > AND > OR.

The **AND** operator returns true if and only if **all** arguments are true.

$$A\cdot B \text{ or }AB$$

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/AND_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)

The **OR** operator returns true if and only if **at least one** argument is true.

$$A+B$$

<img src="https://upload.wikimedia.org/wikipedia/commons/1/16/OR_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **NOT** operator returns the opposite of its singular input.

$$\overline A \text{ or } A'$$

<img src="https://upload.wikimedia.org/wikipedia/commons/6/60/NOT_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **NAND** operator is equivalent to **NOT AND**.

$$\overline{A\cdot B}$$

<img src="https://upload.wikimedia.org/wikipedia/commons/e/e6/NAND_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **NOR** operator is equivalent to **NOT OR**.

$$\overline{A+B}$$

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c6/NOR_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **XOR** operator returns true if and only if the inputs are not equal to each other.

$$A\oplus B$$

<img src="https://upload.wikimedia.org/wikipedia/commons/1/17/XOR_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

The **XNOR** operator is equivalent to **NOT XOR**.

$$\overline{A\oplus B}$$

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b8/XNOR_ANSI_Labelled.svg" width=200>(Source: Wikimedia Commons)</img>

### Buffer gates

The **buffer** gate returns the input without any changes, and is usually used for adding delays into circuits.

<img src="https://upload.wikimedia.org/wikipedia/commons/7/75/Digital_buffer.svg" width=200>(Source: Wikimedia Commons</img>

A **tri-state buffer** gate controls whether the input affects the circuit at all. When the controlling input is off, the input is disconnected from the rest of the system, leaving the output of the buffer as a third state **Z** (high impedance).

One example of a tri-state buffer is a switch.

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c0/Tristate_buffer.svg" width=400>(Source: Wikimedia Commons)</img>

!!! example
    Tri-state buffers are often used to implement **select inputs** or **multiplexers** — setting the mux switch in one direction or another only allows signals from one input to pass through.
    <img src="https://upload.wikimedia.org/wikipedia/commons/1/16/Multiplexer2.svg" width=400>(Source: Wikimedia Commons)</img>

### NAND/NOR completeness

NAND and NOR are **universal gates** — some combination of them can form any other logic gate. Constructions of other gates using only these gates are called **NAND-NAND realisations** or **NOR-NOR realisations**.

This is useful in SOP as if two ANDs feed into an OR, all can be turned into NANDs to achieve the same result.

!!! example
    NOT can be expressed purely with NAND as $A$ NAND $A$:
    
    <img src="https://upload.wikimedia.org/wikipedia/commons/3/3f/NOT_from_NAND.svg" width=150>(Source: Wikimedia Commons)</img>

### Postulates

In binary algebra, if $x,y,z\in\mathbb B$ such that $\mathbb B=\{0, 1\}$:

The **identity element** for **AND** $1$ is such that any $x\cdot 1 = x$.

The **identity element** for **OR** $0$ is such that any $x + 0 = x$.

In this space, it can be deduced that $x+x'=1$ and $x\cdot x'=0$.

**De Morgan's laws** are much easier to express in boolean algebra, and denote distributing a negation by flipping the operator:

$$
(x\cdot y)'=x'+y' \\
(x+y)=x'\cdot y'
$$

Please see [ECE 108: Discrete Math 1#Operator laws](/1b/ece108/#operator-laws) for more information.

AND and OR are commutative.

- $x\cdot y=y\cdot x$
- $x+y=y+x$

AND and OR are associative.

- $x\cdot(y\cdot z)=(x\cdot y)\cdot z)$
- ...

AND and OR are distributive with each other.

- $x\cdot (y+z)=x\cdot y+z\cdot z$

A term that depends on another term ORed together can be "absorbed".

- $x+x\cdot y=x$
- $x\cdot(x+y)=x$

If a term being true also results in other ORed terms being true, it is redundant and can be eliminated via consensus.

- $x\cdot y+y\cdot z+x'\cdot z=x\cdot y+x'\cdot z$
  - if y and z are true, at least one of the other two terms must be true
- $(x+y)\cdot (y+z)\cdot(x'+z)=(x+y)\cdot (x'+z)$

The **synthesis** of an algebraic formula represents its implementation via logic gates. In this course, its total cost is the sum of all inputs to all gates and the number of gates, *excluding* initial inputs of "true" or an initial negation.

In order to deduce an algebraic expression from a truth table, **OR** all of the rows in which the function returns true and simplify.

??? example
    Prove that $(x+y)\cdot(x+y')=x$:
    
    \begin{align*}
    \tag{distributive property}(x+y)\cdot(x+y')&=xx+xy'+yx+yy' \\
    \tag{$yy'$ = 0, $xx=x$}&=x + xy' + yx \\
    \tag{distributive, commutative properties}&= x(1+y'+y) \\
    \tag{1 + ... = 1}&= x(1) \\
    &=x
    \end{align*}
    
    Prove that $xy+yz+x'z=xy+x'z$:
    
    \begin{align*}
    \tag{$x+x'=1$}xy+yz+x'z&=xy+yz(x+x')+x'z \\
    \tag{distributive property}&=xy+xyz+x'yz+x'z \\
    \tag{distributive property}&=x(y+yz) + x'(yz+z) \\
    \tag{distributive property}&=xy(1+z) + x'z(y+1) \\
    \tag{$1+k=1$}&=xy(1) + x'z(1) \\
    \tag{$1\cdot k=k$}&= xy+x'z
    \end{align*}

### Minterms and maxterms

The **minterm** $m$ is a **product** term where all variables in the function appear once. There are $2^n$ minterms for each function, where $n$ is the number of input variables.

To determine the relevant function, the subscript can be converted to binary and each function variable set such that:

- if the digit is $1$, the complement is used, and
- if the digit is $0$, the original is used.

$$m_j=x_1+x_2+\dots x_n$$

!!! example
    For a function that accepts three variables:
    
    - there are eight minterms, from $m_0$ to $m_7$.
    - the sixth minterm $m_6=xyz'$ because $6=0b110$.
    
    For a sample function defined by the following minterms:
    
    $$
    \begin{align*}
    f(x_1,x_2,x_3)&=\sum m(1,2,5) \\
    &=m_1+m_2+m_5 \\
    &=x_1x_2x_3' + x_1x_2'x_3 + x_1'x_2x_3'
    \end{align*}
    $$

The **maxterm** $M$ is a **sum** term where all variables in the function appear once. It is more or less the same as a minterm, except the condition for each variable is **reversed** (i.e., $0$ indicates the complement).

$$M_j=x_1+x_2+\dots +x_n$$

!!! example
    For a sample function defined by the following maxterms:
    
    \begin{align*}
    f(x_1,x_2,x_3,x_4)&=\prod M(1,2,8,12) \\
    &=M_1M_2M_8M_{12} \\
    \end{align*}

??? example
    Prove that $\sum m(1,2,3,4,5,6,7)=x_1+x_2+x_3$: **(some shortcuts taken for visual clarity)**
    
    \begin{align*}
    \sum m(1,2,3,4,5,6,7) &=001+011+111+010+110+100+000 \\
    \tag{SIMD distribution}&=001+010+100 \\
    &=x_1+x_2+x_3
    \end{align*}

A **canonical sum of products (SOP)** is a function expressed as a sum of minterms.

$$f(x_1,x_2,\dots)=\sum m(a,b, \dots)$$

A **canonical product of sums (POS)** is a function expressed as a product of maxterms.

$$f(x_1,x_2,\dots)=\prod M(a,b,\dots)$$

## Transistors

Binary is represented in hardware via switches called **transistors**. Above a certain voltage threshold, its output is $1$, whlie it is $0$ if below a threshold instead.

A transistor has three inputs/outputs:

- A ground
- An input **source**, which has voltage that determines whether the circuit is connected to the ground
- An output **drain**, which will either be grounded or have a voltage depending on whether the switch is closed.

<img src="https://upload.wikimedia.org/wikipedia/commons/6/61/IGFET_N-Ch_Enh_Labelled_simplified.svg" width=200>(Source: Wikimedia Commons)</img>

A **negative logic** transistor uses a NOT bubble to represent that it is closed while the voltage is **below** a threshold.

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c4/IGFET_P-Ch_Enh_Labelled_simplified.svg" width=200>(Source: Wikimedia Commons)</img>

## Hardware

!!! definition
    - A **programmable logic gate** does shit
    - A **programmable logic array** does more shit
    - **Programmable array logic** is the shit being done

### FPGAs

A **field-programmable gate array** (FPGA) is hardware that does not come with factory-fabricated AND and OR gates, requiring the user to set them up themselves. It contains:

- input/output pads
- routing channels (to connect with physical wires and switches)
- logic blocks (that are user-programmed to behave like gates)
    - lookup tables (LUTs) inside the logic gates, which are a small amount of memory

## Gray code

The Gray code is a binary number system that has any two adjacent numbers differing by **exactly one bit**. It is used to optimise the number of gates in a function.

The 1-bit Gray code is $0, 1$. To convert an $n$-bit Gray code to an $n+1$-bit Gray code:

- Mirror the code: $0,1,1,0$
- Add $0$ to the original and $1$ to the new ones: $00, 01, 11, 10$

Sorting truth table inputs in the order of the Gray code makes optimisation easier to do.

A **"don't care"** is represented by a $d$ in truth tables. It is used for optimisation if the state of that output doesn't matter, and can be treated as a one or a zero as desired.

It can be more efficient to optimise two different functions differently such that they are more optimised when combined.

### K-maps

Karnaugh maps are an alternate representation of truth tables arranged by the Gray code.

- Coordinates are the input values to the function
- The output square of the coordinates is the output value of the function
- Headers are sorted by Gray code (multiple variables can be combined by increasing the number of bits in the Gray code)

Each 1 square is effectively a minterm, and finding the least number of rectangles that only cover "1"s allows for the simplest algebraic form of the truth table to be deduced. If needed, rectangles can wrap around on any side. The same rules apply to optimise for maxterms (product of sums), or $f'$, by optimising for zeros.

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b7/K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg" width=500>(Source: Wikimedia Commons)</img>

A K-map for five variables can be expressed in two maps for four variables — one with the fifth variable set to zero, and the other set to 1.

### Multiplexers

An $n$-input mux has $\lceil\log_2 n\rceil$ **select inputs** all in the same mux.

!!! example
    A 4-1 multiplexer. $f=s_0's_1A+s_0's_1B+s_0s_1'C+s_0s_1D$
    
    <img src="https://upload.wikimedia.org/wikipedia/commons/7/75/Multiplexer_4-to-1.svg" width=300>(Source: Wikimedia Commons)</img>

## VHDL

VHDL is a hardware schematic language.

<img src="https://static.javatpoint.com/tutorial/digital-electronics/images/multiplexer3.png" width=600 />

For example, the basic 2-to-1 multiplexer expressed above can be programmed as:

```vhdl
entity two_one_mux is
    port (a0, s, a1 : in    bit;
          f         : out   bit);
end two_one_mux

architecture LogicFunc of two_one_mux is
    begin
        y <= (a0 AND s) OR (NOT s AND a1);
    end LogicFunc;
```

In this case, the inputs are `a0, s, a1` that lead to an output `y`. All input/output is of type `bit` (a boolean).

The **architecture** defines how inputs translate to outputs via functions. These all run **concurrently**.

